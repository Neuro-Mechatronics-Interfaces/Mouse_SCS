// Load necessary libraries and files
load_file("nrngui.hoc")
// loads{ 
//  proc: [progress_tick(), progress_init()]; 
//  vars: [t0, elapsed, per_iter, eta]; 
//  strdef: [bar, msg] }
load_file("progress_utils.hoc") 

// Define sections
create soma, dend[3], ais, axon

// ----- Biophysics -----
soma {
  L = 30
  diam = 40
  insert motoneuron
}

ais {
  L = 30      // ~20–40 µm common
  diam = 1.2  // ~0.8–1.5 µm
  nseg = 3
  insert initial        
}

axon {
  L = 1000
  diam = 2
  nseg = 101
  insert axnode
}

for i=0,2 {
  dend[i] {
    L = 25
    diam = 1
    nseg = 5
    insert motoneuron
  }
}

// Wiring: soma -> AIS -> axon
connect ais(0),  soma(1)
connect axon(0), ais(1)

// Connect dendrites to soma
connect dend[0](1), soma(0)
connect dend[1](1), soma(0)
connect dend[2](1), soma(0)

// ----- Synapses & Stims -----
objref syn0, syn1, syn2, stim0, stim1, stim2

dend[0] { syn0 = new Exp2Syn(0.5)  syn0.e =  80 }  // EPSP
dend[1] { syn1 = new Exp2Syn(0.5)  syn1.e =  80 }  // EPSP
dend[2] { syn2 = new Exp2Syn(0.5)  syn2.e =  80 }  // EPSP

stim0 = new NetStim()
stim1 = new NetStim()
stim2 = new NetStim()
stim0.noise = 0
stim1.noise = 0
stim2.noise = 0
stim0.start = 50

objref nc00, nc01, nc02, nc10, nc11, nc12, nc20, nc21, nc22
nc00 = new NetCon(stim0, syn0)
nc01 = new NetCon(stim0, syn1)
nc02 = new NetCon(stim0, syn2)
nc10 = new NetCon(stim1, syn0)
nc11 = new NetCon(stim1, syn1)
nc12 = new NetCon(stim1, syn2)
nc20 = new NetCon(stim2, syn0)
nc21 = new NetCon(stim2, syn1)
nc22 = new NetCon(stim2, syn2)

// ----- Recording -----
objref tvec, vvec
tvec = new Vector()
vvec = new Vector()
tvec.record(&t)
vvec.record(&axon.v(0.5))

// ----- Sweep controls -----
freq = 10
leak_cur = 0.0
w0 = 1  
w1 = 1  
w2 = 1
blending = 0.0
tstop = 1000
dt = 0.025

// Run once per condition
proc run_simulation() {
    soma.gl_motoneuron = leak_cur
    dend[0].gl_motoneuron = leak_cur
    dend[1].gl_motoneuron = leak_cur
    dend[2].gl_motoneuron = leak_cur

    // Stims by phase
    stim0.interval = 9000 / freq
    stim0.number   = freq
    stim0.start    = 50
    // syn0 primarily
    nc00.weight[0] = p0 * w0
    nc01.weight[0] = p1 * 0                      // syn1 off in phase 0
    nc02.weight[0] = p2 * (0.25 * blending * w0) // blended syn2 in phase 0


    stim1.interval = 9000 / freq
    stim1.start    = 50 + 1000 / freq
    stim1.number   = freq
    // syn1 primarily
    nc10.weight[0] = p0 * 0
    nc11.weight[0] = p1 * w1
    nc12.weight[0] = p2 * (blending * w1)

    stim2.interval = 9000 / freq
    stim2.start    = 50 + 2000 / freq
    stim2.number   = freq
    // syn2 primarily
    nc20.weight[0] = p0 * 0
    nc21.weight[0] = p1 * 0
    nc22.weight[0] = p2 * w2

    // Clear previous traces before this run
    tvec.resize(0)
    vvec.resize(0)

    finitialize(-65)
    run()
}

// ----- Sweeps (unchanged except for mechanism names above) -----
objref blend_levels, m2_levels, leak_levels, frequencies, w0_levels, w1_levels, w2_levels
leak_levels = new Vector()
leak_levels.append(0.0005)
leak_levels.append(0.005)

m2_levels = new Vector()
m2_levels.append(1.0)

blend_levels = new Vector()
blend_levels.append(0.0)
blend_levels.append(0.5)

frequencies = new Vector()
frequencies.append(3)
frequencies.append(30)
frequencies.append(300)
frequencies.append(3000)

// Pulse sequencing weights
w0_levels = new Vector()  
w1_levels = new Vector()  
w2_levels = new Vector()
// Constant
w0_levels.append(30)  
w1_levels.append(30)  
w2_levels.append(30)  

// ---- Synaptic polarity presets (sequence modes) ----
// mode 0: EPSP only           (80,  80,  80)
// mode 1: IPSP,IPSP,EPSP     (-80, -80,  80)   
// mode 2: IPSP only          (-80, -80, -80)
// mode 3: Mixed A            (-80,  80,  80)   // example
// mode 4: Mixed B            ( 80, -80,  80)   // example

objref seq_modes
seq_modes = new Vector()
seq_modes.append(0)
seq_modes.append(1)
seq_modes.append(3)

strdef seqname, seqabbr
proc set_seq_mode() { local mode
  mode = $1
  if (mode==0) {
    syn0.e =  80  
    syn1.e =  80  
    syn2.e =  80
    sprint(seqname, "EPSP_only")
    sprint(seqabbr, "E3")
  } else if (mode==1) {
    syn0.e = -80  
    syn1.e = -80  
    syn2.e =  80
    sprint(seqname, "IPSP_IPSP_EPSP")
    sprint(seqabbr, "IIE")
  } else if (mode==2) {
    syn0.e = -80  
    syn1.e = -80  
    syn2.e = -80
    sprint(seqname, "IPSP_only")
    sprint(seqabbr, "I3")
  } else if (mode==3) {
    syn0.e = -80  
    syn1.e =  80  
    syn2.e = -80
    sprint(seqname, "IPSP_EPSP_IPSP")
    sprint(seqabbr, "IEI")
  } else if (mode==4) {
    syn0.e =  80  
    syn1.e = -80  
    syn2.e =  80
    sprint(seqname, "EPSP_IPSP_EPSP")
    sprint(seqabbr, "EIE")
  } else {
    // Fallback: leave as-is
    sprint(seqname, "custom")
    sprint(seqabbr, "CUST")
  }
}

// ---- Base pulse intensities per synapse (scales NetCon weights) ----
// These multiply your w0/w1/w2 sequence weights inside run_simulation().
objref p0_levels, p1_levels, p2_levels
p0_levels = new Vector()
p1_levels = new Vector()
p2_levels = new Vector()

// Can be used to modify gain on each postsynaptic potential
p0_levels.append(1.0)   
p1_levels.append(1.0)   
p2_levels.append(1.0)   // equal

// ---- Metadata writers ----
objref frout, m2out, leakout, blendout, seqout, pout, wout

proc save_metadata() { local i, pi_n0, pi_n1, pi_n2, pi_n
  frout = new File()   frout.wopen("out_leak/frequencies.dat")   frequencies.printf(frout, "%g\n")   frout.close()
  m2out = new File()   m2out.wopen("out_leak/m2_levels.dat")     m2_levels.printf(m2out, "%g\n")     m2out.close()
  leakout = new File() leakout.wopen("out_leak/leak_levels.dat") leak_levels.printf(leakout, "%g\n") leakout.close()
  blendout = new File() blendout.wopen("out_leak/blending_levels.dat") blend_levels.printf(blendout, "%g\n") blendout.close()

  // sequence modes table
  seqout = new File()  seqout.wopen("out_leak/syn_sequence_modes.tsv")
  seqout.printf("mode\tname\tsyn0.e\tsyn1.e\tsyn2.e\n")
  for i=0, seq_modes.size()-1 {
    set_seq_mode(seq_modes.x[i])
    seqout.printf("%d\t%s\t%g\t%g\t%g\n", seq_modes.x[i], seqname, syn0.e, syn1.e, syn2.e)
  }
  seqout.close()

  // pulse intensity triplets
  pout = new File()  pout.wopen("out_leak/pulse_intensities.tsv")
  pout.printf("row\tp0\tp1\tp2\n")
  pi_n0 = p0_levels.size()
  pi_n1 = p1_levels.size()
  pi_n2 = p2_levels.size()
  pi_n = pi_n0
  if (pi_n1 < pi_n) { pi_n = pi_n1 }
  if (pi_n2 < pi_n) { pi_n = pi_n2 }
  for i=0, pi_n-1 {
    pout.printf("%d\t%g\t%g\t%g\n", i, p0_levels.x[i], p1_levels.x[i], p2_levels.x[i])
  }
  pout.close()

  // ---- Write weights metadata ----
  // One row per "pattern" index c; aligns with w0_levels/w1_levels/w2_levels
  wout = new File()
  wout.wopen("out_leak/weights.tsv")
  wout.printf("row\tW1\tW2\tW3\n")
  for c = 0, w2_levels.size()-1 {
    wout.printf("%d\t%g\t%g\t%g\n", c, w0_levels.x[c], w1_levels.x[c], w2_levels.x[c])
  }
  wout.close()
}

func nconds() { local n
  n = seq_modes.size() \
    * p0_levels.size() \
    * w2_levels.size() \
    * leak_levels.size() \
    * m2_levels.size() \
    * frequencies.size() \
    * blend_levels.size()
  return n
}

// ---- Run all conditions and export ----
objref vout, tout, hb, done
proc run_all_conditions() { local runidx, total, total_runs
  total_runs = nconds()
  save_metadata()
  runidx = 0
  progress_init(total_runs)

  // compute common pi_n once
  pi_n0 = p0_levels.size()  pi_n1 = p1_levels.size()  pi_n2 = p2_levels.size()
  pi_n = pi_n0  if (pi_n1 < pi_n) { pi_n = pi_n1 }  if (pi_n2 < pi_n) { pi_n = pi_n2 }

  for sm = 0, seq_modes.size()-1 {
    set_seq_mode(seq_modes.x[sm])

    for pi = 0, pi_n-1 {
      p0 = p0_levels.x[pi]  p1 = p1_levels.x[pi]  p2 = p2_levels.x[pi]

      for c = 0, w2_levels.size()-1 {
        for l = 0, leak_levels.size()-1 {
          leak_cur = leak_levels.x[l]
          for k = 0, m2_levels.size()-1 {
            m2_cur = m2_levels.x[k]
            for i = 0, frequencies.size()-1 {
              for bl = 0, blend_levels.size()-1 {
                freq     = frequencies.x[i]
                blending = blend_levels.x[bl]
                w0 = w0_levels.x[c]
                w1 = w1_levels.x[c]
                w2 = w2_levels.x[c]

                runidx = runidx + 1
                progress_tick(runidx, total_runs)

                run_simulation()

                // Save traces — include seq and p-triplet tags
                strdef filename_voltage, filename_time
                sprint(filename_voltage, "out_leak/voltage_%s_p%.2f_%.2f_%.2f_%g_%g_%g_%ggl_%gm2_%gblend_%dHz.dat", \
                                      seqabbr, p0, p1, p2, w0, w1, w2, leak_cur, m2_cur, blending, freq)
                sprint(filename_time,    "out_leak/time_%s_p%.2f_%.2f_%.2f_%g_%g_%g_%ggl_%gm2_%gblend_%dHz.dat",    \
                                      seqabbr, p0, p1, p2, w0, w1, w2, leak_cur, m2_cur, blending, freq)

                vout = new File()  vout.wopen(filename_voltage)  vvec.printf(vout, "%g\n")  vout.close()
                tout = new File()  tout.wopen(filename_time)     tvec.printf(tout, "%g\n")  tout.close()
                hb = new File()
                hb.wopen("out_leak/heartbeat.txt")
                hb.printf("{\"k\":%d,\"total\":%d,\"elapsed\":%.3f,\"eta\":%.3f}\n", k, total, elapsed, eta)
                hb.close()
              }
            }
          }
        }
      }
    }
  }
  printf("Done.\n")
  done = new File()
  done.wopen("out_leak/done.marker")
  done.printf("ok\n")
  done.close()
}

run_all_conditions()
quit()
