// Load necessary libraries and files
load_file("nrngui.hoc")

// Define soma and dendrites
create soma, dend[3]

soma {
    L = 30 // length
    diam = 30 // diameter
    insert hh // insert Hodgkin-Huxley channels
	insert motoneuron_m2 // insert motor neuron properties
}

for i=0,2 {
    dend[i] {
        L = 100 + 100 * i
        diam = 1 + i
        nseg = 5
        insert pas // passive properties
		insert motoneuron_m2
    }
}

// Connect dendrites to the soma
connect dend[0](0), soma(1)
connect dend[1](0), soma(1)
connect dend[2](0), soma(1)

// Create and configure axon (assuming axon is already defined in MRGaxon.hoc)
// Example axon setup (this may differ based on the original file's content)
create axon
axon {
    L = 1000
    diam = 1
    insert hh
	insert motoneuron_m2
}

// Connect axon to the soma
connect soma(0), axon(1)

objref syn0, syn1, syn2, stim0, stim1, stim2

dend[0] {
    syn0 = new Exp2Syn(0.5) // use the synaptic mechanism from the mod files
    syn0.tau1 = 0.5 // rise time constant
    syn0.tau2 = 2 // decay time constant
    syn0.e = 0 // reversal potential
}
dend[1] {
    syn1 = new Exp2Syn(0.5) // use the synaptic mechanism from the mod files
    syn1.tau1 = 0.5 // rise time constant
    syn1.tau2 = 2 // decay time constant
    syn1.e = 0 // reversal potential
}
dend[2] {
    syn2 = new Exp2Syn(0.5) // use the synaptic mechanism from the mod files
    syn2.tau1 = 0.5 // rise time constant
    syn2.tau2 = 2 // decay time constant
    syn2.e = 0 // reversal potential
}

// Stimulus to generate EPSPs at a specified rate
stim0 = new NetStim(0.5)
stim0.interval = 300 // interval in ms
stim0.number = 10 // number of spikes
stim0.start = 50 // start time in ms
stim0.noise = 0 // no variability in spike timing

stim1 = new NetStim(0.5)
stim1.interval = 300 // interval in ms
stim1.number = 10 // number of spikes
stim1.start = 150 // start time in ms
stim1.noise = 0 // no variability in spike timing

stim2 = new NetStim(0.5)
stim2.interval = 300 // interval in ms
stim2.number = 10 // number of spikes
stim2.start = 250 // start time in ms
stim2.noise = 0 // no variability in spike timing


// Connect stimulus to synapse
objref nc0, nc1, nc2
nc0 = new NetCon(stim0, syn0)
nc0.weight[0] = 0.05 // synaptic weight
nc1 = new NetCon(stim1, syn1)
nc1.weight[0] = 0.05
nc2 = new NetCon(stim2, syn2)
nc2.weight[0] = 0.05

// Record time and voltage
objref tvec, vvec
tvec = new Vector()
vvec = new Vector()
tvec.record(&t)
vvec.record(&soma.v(0.5))

// Simulation parameters
tstop = 1000 // stop time in ms
dt = 0.025 // time step

// Initialize and run the simulation
finitialize(-65)
run()

// Record time and voltage
objref tvec, vvec
tvec = new Vector()
vvec = new Vector()
tvec.record(&t)
vvec.record(&soma.v(0.5))

freq = 10
m2_cur = 0.5
w0 = 1
w1 = 1
w2 = 1

// Function to run the simulation and record voltage
proc run_simulation() {
    soma.m2_modulation_motoneuron_m2 = m2_cur // Set the m2 modulation level
    stim0.interval = 3000 / freq // Set the stimulation frequency
    stim0.number = freq
	nc0.weight[0] = w0
    stim1.interval = 3000 / freq
    stim1.start = (1000 / freq) + 50
    stim1.number = freq
	nc1.weight[0] = w1
    stim2.interval = 3000 / freq
    stim2.start = (2000 / freq) + 50
    stim2.number = freq
	nc2.weight[0] = w2

    // Simulation parameters
    tstop = 1000 // stop time in ms
    dt = 0.025 // time step

    // Initialize and run the simulation
    finitialize(-65)
    run()
}

// Sweep through frequencies
objref m2_levels, frequencies, w0_levels, w1_levels, w2_levels
m2_levels = new Vector() // 3 modulation levels
m2_levels.append(0.1)
m2_levels.append(1.0)
m2_levels.append(10.0)
frequencies = new Vector() // 9 frequencies
frequencies.append(10)
frequencies.append(20)
frequencies.append(30)
frequencies.append(40)
frequencies.append(50)
frequencies.append(75)
frequencies.append(100)
frequencies.append(150)
frequencies.append(200)

// 4 combinations of stim pulse sequencing weights
w0_levels = new Vector()
w1_levels = new Vector()
w2_levels = new Vector()
// "Constant" sweep
w0_levels.append(30)
w1_levels.append(30)
w2_levels.append(30)
// "Increasing" sweep
w0_levels.append(10)
w1_levels.append(30)
w2_levels.append(50)
// "Up-Down" sweep
w0_levels.append(20)
w1_levels.append(50)
w2_levels.append(20)
// "Decreasing" sweep
w0_levels.append(50)
w1_levels.append(30)
w2_levels.append(10)

// Takes ~1 minute to process 18 simulation runs at dt = 0.025 and tstop = 1000. 
// --> ~2 minutes to complete all frequencies/weight-levels for a single m2 level
// ----> ~6 minutes for a full simulation run.

objref vout, tout
for c = 0, w2_levels.size()-1 {
	for k = 0, m2_levels.size()-1 {
		m2_cur = m2_levels.x[k]
		for i = 0, frequencies.size()-1 {
			freq = frequencies.x[i]
			w0 = w0_levels.x[c]
			w1 = w1_levels.x[c]
			w2 = w2_levels.x[c]
			run_simulation()
			// Save the recorded voltage data to a file
			strdef filename_voltage, filename_time
			sprint(filename_voltage, "out/voltage_%g_%g_%g_%gm2_%dHz.dat", w0, w1, w2, m2_cur, freq)
			sprint(filename_time, "out/time_%g_%g_%g_%gm2_%dHz.dat", w0, w1, w2, m2_cur, freq) 
			vout = new File()
			vout.wopen(filename_voltage) // Overwrite mode (recreate the file each time)
			vvec.printf(vout, "%g\n")
			vout.close()
			// Save recorded times to a file
			tout = new File()
			tout.wopen(filename_time) // Write mode (create/overwrite file)
			tvec.printf(tout, "%g\n")
			tout.close()
		}
	}
}

objref frout, m2out
proc save_metadata() {
	frout = new File()
	frout.wopen("out/frequencies.dat")
	frequencies.printf(frout, "%g\n")
	frout.close()
	m2out = new File()
	m2out.wopen("out/m2_levels.dat")
	m2_levels.printf(m2out, "%g\n")
	m2out.close()
}

save_metadata()

quit()