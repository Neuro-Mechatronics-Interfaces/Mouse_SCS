// Load necessary libraries and files
load_file("nrngui.hoc")

// Define sections
create soma, dend[3], ais, axon

// ----- Biophysics -----
soma {
  L = 30
  diam = 40
  insert motoneuron_ff  // FF phenotype
  // Optional FF tuning knobs (uncomment/tune as desired)
  // gnabar_motoneuron_ff = 0.09
  // gkrect_motoneuron_ff = 0.40
  // gcaN_motoneuron_ff   = 0.02
  // gcaL_motoneuron_ff   = 0.0004
  // gcak_motoneuron_ff   = 0.60
  // tau_p_motoneuron_ff  = 500
  // alpha_ca_motoneuron_ff = 0.02
  // k_cleak_motoneuron_ff  = 0.5
}

ais {
  L = 30      // ~20–40 µm common
  diam = 1.2  // ~0.8–1.5 µm
  nseg = 3
  insert initial           // keep same AIS params you had
  // (optionally) tweak AIS:
  // gnabar_initial = 0.5
  // gnap_initial   = 0.01
  // gkrect_initial = 0.1
  // gl_initial     = 0.01
}

axon {
  L = 1000
  diam = 2
  nseg = 101
  insert motoneuron_ff
  gnabar_motoneuron_ff = 0.30  // your prior axonal Na boost
}

// Wiring: soma -> AIS -> axon
connect ais(0),  soma(1)
connect axon(0), ais(1)

// Dendrites
for i=0,2 {
  dend[i] {
    L = 25
    diam = 1
    nseg = 5
    insert pas
    g_pas = 0.0005     // <-- use g_pas (not gnabar)
    e_pas = -70
  }
}

// Connect dendrites to soma
connect dend, soma(1)
connect dend, soma(1)
connect dend, soma(1)

// ----- Synapses & Stims -----
objref syn0, syn1, syn2, stim0, stim1, stim2

dend[0] { syn0 = new Exp2Syn(0.5)  syn0.e = -80 }  // IPSP
dend[1] { syn1 = new Exp2Syn(0.5)  syn1.e = -80 }  // IPSP
dend[2] { syn2 = new Exp2Syn(0.5)  syn2.e =   0 }  // EPSP

stim0 = new NetStim()
stim1 = new NetStim()
stim2 = new NetStim()
stim0.noise = 0
stim1.noise = 0
stim2.noise = 0
stim0.start = 50

objref nc00, nc01, nc02, nc10, nc11, nc12, nc20, nc21, nc22
nc00 = new NetCon(stim0, syn0)
nc01 = new NetCon(stim0, syn1)
nc02 = new NetCon(stim0, syn2)
nc10 = new NetCon(stim1, syn0)
nc11 = new NetCon(stim1, syn1)
nc12 = new NetCon(stim1, syn2)
nc20 = new NetCon(stim2, syn0)
nc21 = new NetCon(stim2, syn1)
nc22 = new NetCon(stim2, syn2)

// ----- Recording -----
objref tvec, vvec
tvec = new Vector()
vvec = new Vector()
tvec.record(&t)
vvec.record(&axon.v(0.5))

// ----- Sweep controls -----
freq = 10
leak_cur = 0.0
w0 = 1  w1 = 1  w2 = 1
blending = 0.0
tstop = 1000
dt = 0.025

// Run once per condition
proc run_simulation() {
    // Set leak on the FF mechanism at soma
    soma.gl_motoneuron_ff = leak_cur
    // (Removed m2_modulation_motoneuron_m2 — not in FF mech)

    // Stims by phase
    stim0.interval = 9000 / freq
    stim0.number   = freq
    stim0.start    = 50
    nc00.weight[0] = w0
    nc01.weight[0] = 0
    nc02.weight[0] = 0.25 * blending * w0

    stim1.interval = 9000 / freq
    stim1.start    = 50 + 1000 / freq
    stim1.number   = freq
    nc10.weight[0] = 0
    nc11.weight[0] = w1
    nc12.weight[0] = blending * w1

    stim2.interval = 9000 / freq
    stim2.start    = 50 + 2000 / freq
    stim2.number   = freq
    nc20.weight[0] = 0
    nc21.weight[0] = 0
    nc22.weight[0] = w2

    // Clear previous traces before this run
    tvec.resize(0)
    vvec.resize(0)

    finitialize(-65)
    run()
}

// ----- Sweeps (unchanged except for mechanism names above) -----
objref blend_levels, m2_levels, leak_levels, frequencies, w0_levels, w1_levels, w2_levels
leak_levels = new Vector()
leak_levels.append(0.002)
leak_levels.append(0.007)

m2_levels = new Vector()
m2_levels.append(0.1)
m2_levels.append(1.0)
m2_levels.append(10.0)

blend_levels = new Vector()
blend_levels.append(0.0)
blend_levels.append(0.2)
blend_levels.append(0.5)

frequencies = new Vector()
frequencies.append(10)
frequencies.append(30)
frequencies.append(50)
frequencies.append(100)

// Pulse sequencing weights
w0_levels = new Vector()  w1_levels = new Vector()  w2_levels = new Vector()
w0_levels.append(30)  w1_levels.append(30)  w2_levels.append(30)  // Constant
w0_levels.append(10)  w1_levels.append(30)  w2_levels.append(50)  // Increasing
w0_levels.append(20)  w1_levels.append(50)  w2_levels.append(20)  // Up-Down
w0_levels.append(50)  w1_levels.append(30)  w2_levels.append(10)  // Decreasing

// Save metadata (as before)
objref frout, m2out, leakout, blendout
proc save_metadata() {
  frout = new File()   frout.wopen("out/frequencies.dat")   frequencies.printf(frout, "%g\n")   frout.close()
  m2out = new File()   m2out.wopen("out/m2_levels.dat")     m2_levels.printf(m2out, "%g\n")     m2out.close()
  leakout = new File() leakout.wopen("out/leak_levels.dat") leak_levels.printf(leakout, "%g\n") leakout.close()
  blendout = new File() blendout.wopen("out/blending_levels.dat") blend_levels.printf(blendout, "%g\n") blendout.close()
}
save_metadata()

// Run all conditions and export
objref vout, tout
for c = 0, w2_levels.size()-1 {
  for l = 0, leak_levels.size()-1 {
    leak_cur = leak_levels.x[l]
    for k = 0, m2_levels.size()-1 {
      m2_cur = m2_levels.x[k]     // kept for filenames; not used by FF mech
      for i = 0, frequencies.size()-1 {
        for bl = 0, blend_levels.size()-1 {
          freq     = frequencies.x[i]
          blending = blend_levels.x[bl]
          w0 = w0_levels.x[c]
          w1 = w1_levels.x[c]
          w2 = w2_levels.x[c]

          run_simulation()

          // Save traces
          strdef filename_voltage, filename_time
          sprint(filename_voltage, "out/voltage_%g_%g_%g_%ggl_%gm2_%gblend_%dHz.dat", w0, w1, w2, leak_cur, m2_cur, blending, freq)
          sprint(filename_time,    "out/time_%g_%g_%g_%ggl_%gm2_%gblend_%dHz.dat",    w0, w1, w2, leak_cur, m2_cur, blending, freq)
          vout = new File()  vout.wopen(filename_voltage)  vvec.printf(vout, "%g\n")  vout.close()
          tout = new File()  tout.wopen(filename_time)     tvec.printf(tout, "%g\n")  tout.close()
        }
      }
    }
  }
}

quit()
